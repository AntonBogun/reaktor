600 REM print maze
610 IF maze_drawn THEN GOTO 730
620 LET maze_drawn = 1
630 LET pr = PEEK(1) : LET pc = PEEK(2) : REM player row, column
640 CLS : REM the first time around we need to draw the maze
650 LOCATE 2,1
660 FOR row = 0 TO height-1
670     LET s$ = ""
680     FOR col = 0 TO width-1
690         LET cell = PEEK(16 + row * width + col)
700         s$ = s$ + MID$(" X", cell, 1)
710     NEXT col : PRINT s$
720 NEXT row
730 REM erase the previous player position and print the new one
740 LOCATE 2+pr, 1+pc : PRINT " ";
750 pr = PEEK(1) : pc = PEEK(2)
760 LOCATE 2+pr, 1+pc : PRINT "@";
770 REM print the number of steps so far
780 LOCATE 1,10 : PRINT "STEPS: "; steps;
790 LET steps = steps + 1
800 RETURN

1000 REM find next rotation
if calc_path then goto 'skip_calc_path' : REM a way to call a subroutine
calc_path = 1
'init'()
'create_grid'()
'create_deque'()
'find_path'()
REM 'debug_printout'()
def 'skip_calc_path' REM change peek(0) to direction in the cell (-1)
playerx=peek(2):playery=peek(1)
playerdir=grid(playerx,playery)-1
if playerdir=-1 then return : REM reached target
poke 0,playerdir
REM locate peek(6),1
REM print playerdir;
REM print sizex;";";sizey;";";endx;";";endy;";";
REM print r1;";";r2;";";r3;";";deqtest;
REM 'debug_printout'()
REM 'printout_stack'()
return


REM NOTE::
REM for ... is inclusive
REM dim ... isn't
REM anything after REM is a comment

def 'init' r1=0:r2=0:r3=0:r4=0:r5=0:r6=0:r7=0:r8=0:r9=0 : REM registers
REM note: r0\d+ are not initialized as they are private variables and should be initialized inside the functions anyway
sizex=peek(15):sizey=peek(14) : REM size of grid
REM startx=peek(2):starty=peek(1) : REM start position, thought not used as find_path finds all paths
endx=peek(13):endy=peek(12) : REM end position
dim debugstack(500) : REM debug printout
dspointer=0 : REM debug printout pointer
return

def 'add_printout' REM add r1 to debugstack
debugstack(dspointer)=r1 : dspointer=dspointer+1
return

def 'printout_stack' REM and empty
locate peek(6)-3,1
for i=0 to dspointer-1
    print debugstack(i);";";
next i
return


def 'create_grid' dim grid(1)
dim grid(sizex,sizey)
for x=0 to sizex-1: for y=0 to sizey-1:grid(x,y)=peek(16+x+y*sizex):next:next
return

def 'debug_printout' locate 2,1 :REM begin of grid
for y=0 to sizey-1 : prntout$="" : for x=0 to sizex-1
if (x>=0) and (x<10) then x$=chr$(48+x):else x$="?"
prntout$=prntout$+x$ : next x
locate 2+y,1 : print prntout$; : next y
return

def 'create_deque' dim deque(1)
dim deque(1000)
dsize=1000:lend=0:rend=0
return

REM deque lend,rend point to [start,end) of deque
REM isEmpty= (lend=rend)
REM length is not implemented

REM remake that takes less space
def 'insertleft' r0=1:goto 'insertlmain'
def 'insertleft2' r0=2:goto 'insertlmain'
def 'insertleft3' r0=3:goto 'insertlmain'
def 'insertlmain' if lend then lend=lend-1 : else lend=dsize-1
deque(lend)=r1
if r0<2 then return
if lend then lend=lend-1 : else lend=dsize-1
deque(lend)=r2
if r0<3 then return
if lend then lend=lend-1 : else lend=dsize-1
deque(lend)=r3
return


def 'popright' r0=1:goto 'poprmain'
def 'popright2' r0=2:goto 'poprmain'
def 'popright3' r0=3:goto 'poprmain'
def 'poprmain' if rend then rend=rend-1 : else rend=dsize-1
r1=deque(rend)
if r0<2 then return
if rend then rend=rend-1 : else rend=dsize-1
r2=deque(rend)
if r0<3 then return
if rend then rend=rend-1 : else rend=dsize-1
r3=deque(rend)
return

def 'insertright' r0=1:goto 'insertrmain'
def 'insertright2' r0=2:goto 'insertrmain'
def 'insertright3' r0=3:goto 'insertrmain'
def 'insertrmain' deque(rend)=r1
if rend=dsize-1 then rend=0: else rend=rend+1
if r0>=2 then deque(rend)=r2 : else return
if rend=dsize-1 then rend=0: else rend=rend+1
if r0>=3 then deque(rend)=r3 : else return
if rend=dsize-1 then rend=0: else rend=rend+1
return

def 'popleft' r0=1:goto 'poplmain'
def 'popleft2' r0=2:goto 'poplmain'
def 'popleft3' r0=3:goto 'poplmain'
def 'poplmain' r1=deque(lend)
if lend=dsize-1 then lend=0: else lend=lend+1
if r0>=2 then r2=deque(lend) : else return
if lend=dsize-1 then lend=0: else lend=lend+1
if r0>=3 then r3=deque(lend) : else return
if lend=dsize-1 then lend=0: else lend=lend+1
return

REM deque length = lend-rend, isempty = lend=rend

def 'decode' REM take integer in r1 (32 signed) and decode into r1(0:14),r2(15:29) (15 unsigned)
REM there are no bitwise operations, so we have to do it manually
r2=r1/32768
r1=r1-(r1/32768*32768)
return
def 'encode' REM take r1(0:14),r2(15:29) and encode into integer r1
r1=r1+r2*32768
return

REM convert int 0-3 to 1,0,-1,0 : abs(2-x)-1
REM convert int 0-3 to 0,1,0,-1 : 1-abs(x-1)


def 'numlen' if r1<0 then r0=2 : else r0=1
r1=r1/10:if r1<>0 then r0=r0+1 :goto 1001: else r1 = r0 :return
REM calculates the number of digits in r1, returns r1

def 'newline' newline$="":for x=r1 to peek(5):newline$=newline$+" ":next:return
REM returns spaces to add to a string to act as a newline in singular printout, r1=current column (1-based) the cursor is at


def 'add_neighbours' REM add neighbours (if not visited) of cell (r1,r2) to deque
REM have to make dir+1 as otherwise 0 would be counted as nothing
r3=r1:r4=r2
if r3<(sizex-1) then
if grid(r3+1,r4)=0 then 'insertright2'(r3+1,r4):grid(r3+1,r4)=3
end if
if r3>0 then
if grid(r3-1,r4)=0 then 'insertright2'(r3-1,r4):grid(r3-1,r4)=1
end if
if r4<(sizey-1) then
if grid(r3,r4+1)=0 then 'insertright2'(r3,r4+1):grid(r3,r4+1)=4
end if
if r4>0 then
if grid(r3,r4-1)=0 then 'insertright2'(r3,r4-1):grid(r3,r4-1)=2
end if
REM why are both parts of an and evaluated, even if one is false?
return


def 'find_path' REM put 1:4 (0:3-1) into grid, which lead to end position (uses BFS)
REM visited(x,y) = if grid(x,y) is not zero
REM end cell is -1
'add_neighbours'(endx,endy)
grid(endx,endy)=-1
def 'whiledeque' if (lend=rend) then return
'popleft2'()
'add_neighbours'()
goto 'whiledeque'
